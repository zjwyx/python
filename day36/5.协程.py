# 进程
# 线程
    # 正常的开发语言，多线程可以利用多核
    # cpython解释器下的多个线程不能利用多核：规避了所有io操作的单线程
# 协程
    # 是操作系统不可见的
    # 协程本质就是一条线程  多个任务在一条线程上来回切换
    # 利用协程这个概念实现的内容：来规避io操作，就达到了我们将一条线程中io操作降到最低的目的


# import time
# def func1():
#     print('start')
#     time.sleep(1)
#     print('end')
#
# def func2():
#     print('start')
#     time.sleep(1)
#     print('end')




# 切换 并 规避io 的两个模块
# gevent  =  利用了  greenlet   底层模块完成了切换 + 启动规避io的功能
# asyncio =  利用了  yield   底层模块完成了切换 + 启动规避io的功能
    # tornado 异步的web框架
    # yield from - 更好的实现协程
    # send - 更好的实现协程
    # asyncio模块 基于python原生的协程的概念正式的被成立
    # 特殊的在python中提供协程功能的关键字：aysnc，await


# 进程：数据隔离  数据不安全  操作系统级别   开销非常大    能利用多核
# 线程：数据共享  数据不安全  操作系统级别   开销小       不能利用多核     一些和文件操作相关的io只有操作系统能感知到
# 协程：数据共享  数据安全    用户级别      更小         不能利用多核    协程的所有的切换都基于用户，那么只有在用户级别能够感知到的io操作才会用协程模块做切换来规避


# 用户级别的协程还有什么好处：
    # 减轻了操作系统的负担
    # 一条线程如果开了多个协程，那么给操作系统的印象是线程很忙，这样能多争取一些时间片时间来被CPU执行，程序的效率就提高了


a = 0
def func():
    global a
    a += 1

import dis
dis.dis(func)

# 对于操作系统：python代码 -->编译-->字节码-->解释-->二进制1010101010
# 二进制 反编译过来的 --> LOAD GLOBAL

